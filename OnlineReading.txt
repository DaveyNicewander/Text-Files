Derived Classes Using Inheritance

Using derived classes via inheritance is an extremely powerful tool that can be tempting to use for many reasons. One of the most prevalent reasons is the fact that derived classes allow you to extend the functionality of functions in your base class. This can prove to be rather useful; especially in situations where you don’t have direct access to the code in your base class. You can simply create your derived class and add the extra functionality you need. However, it is important to remember that base objects don’t have access to functions in their derived classes if the function is not also declared in the base object. It is also possible to redefine base functionality entirely with a derived class. To make this happen, all you have to do is redefine the original base function in your derived class with the intended definition. It is important that the two function’s return types, names, and parameters match though. If the names or parameters are different, the derived object’s function will be seen as an added function. If the return types are different, an error will occur. Also, a function can be completely redefined as public or private in the derived class. If completely hiding the base’s version of a function is not desired, it is possible to simply add to the existing functionality of the base object’s function. This is done by having the derived function call the base function and then do whatever else you need afterwards. In the derived function, you call the intended base function like you normally would, but you must prefix the function with the name of the base class and two colons (Base::function():). It is important to remember the scope qualifier (::) when doing this. Otherwise, C++ will default to the function of that name in the current class, which could be nasty. Lastly, it is possible to hide functionality using derived classes.  This can be done by redefining a public base function as private in the derived class. However, instead of redefining the function, this can be done with less code by using the scope resolution operator. This is done by taking the function declared as protected in the base class, showing that it exists in the base class using the :: operator, and calling it without the () operator attached at the end in either the public or private section of the derived class (depending on what you want to accomplish).

OOP and Game Development

Object Oriented Programming (or OOP) is a method of organizing code that allows for easy future maintenance and flexibility. In OOP code is organized into objects which contain information about state and behavior. States are attributes the object has and behaviors are things that the object can do. In my opinion, OOP is extremely useful because it makes creating coded versions of real things much easier. It takes less thought to say that an object called Computer has a piece called Processor and can perform an action like Display. OOP is also useful because it prevents constant copying and pasting of code. Simply create an object with the necessary attributes and behaviors and then use it as needed. 

Cohesion

Cohesion is the idea of grouping code together by intended task. OOP automatically leans towards cohesion because it involves the separation of code into objects. Then, objects are further broken down into attributes and behaviors. Cohesion is useful because it makes code understandable, easy to maintain, and reusable. 
Coupling
Coupling is the idea of separating objects in order to keep them from modifying one another’s attributes or behaviors. It is beneficial to work towards having loosely coupled code so that changing an object won’t unintentionally affect another object. Loose coupling makes code much more flexible. Tightly coupled code can be almost impossible to reuse because it is difficult to separate.

Encapsulation 

Encapsulation is the idea of hiding implementation. It holds that being able to use something is more important than really needing to know EXACTLY how it works. It is important because it makes code more loosely coupled by hiding the nasty details. When these details are hidden, it helps to keep objects from changing one another’s attributes and behavior. Encapsulation can also be helpful when changing the data type of a variable. 

Abstraction 

Abstraction is basically the generalization of code down to its basic principles. It takes specific instances of objects and extracts their common qualities. Abstraction helps to make code less redundant. By taking common qualities of objects and abstracting them, you can create more maintainable code. 

Inheritance

Inheritance allows one object to obtain all or some of the attributes and behaviors of another object. Child classes bear some or all of their parent classes’ properties. Using inheritance may involve the use of the “protected” access level modifier. It basically acts like “private” except that it allows child classes to access the protected section. It may be obvious, but it’s important to say that inheritance is useful because it really cuts down on code redundancy by taking common properties of objects and putting them in one convenient location. It also makes code easy to maintain by avoiding the ripple effect when changing code. 

Version Control

Version control is absolutely essential when working in a group and it can be a convenient tool when working alone. It allows you to keep track of changes made to source code. Most version control software will even state which group member made the changes. Simply put, version control makes it possible to organize almost every aspect of your project. It also makes it easier to add features to your project without breaking it and causing you to tear your hair out. 
Making use of some sort of version control software would have seriously helped Orville and me on our Fightopia project. First, where I’m commuter, it would’ve allowed us to quickly exchange updated versions in an organized way without requiring us to meet up and put out pieces of code together. Second, and most importantly, it would’ve let us work on each individual feature without breaking our entire game. (That was a problem we had quite often) We spent A LOT of time going back through our code trying to figure out what we did wrong. I honestly hope we get to use version control software on our next project. It would help simplify the whole process.
